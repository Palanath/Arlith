package pala.apps.arlith.backend.common.protocol.requests;

import pala.apps.arlith.backend.client.requests.Inquiry;
import pala.apps.arlith.backend.common.protocol.IllegalCommunicationProtocolException;
import pala.apps.arlith.backend.common.protocol.errors.CommunicationProtocolError;
import pala.apps.arlith.backend.common.protocol.errors.CommunicationProtocolErrorDiscerner;
import pala.apps.arlith.backend.common.protocol.errors.ObjectNotFoundError;
import pala.apps.arlith.backend.common.protocol.errors.RateLimitError;
import pala.apps.arlith.backend.common.protocol.errors.ServerError;
import pala.apps.arlith.backend.common.protocol.errors.SyntaxError;
import pala.apps.arlith.backend.common.protocol.meta.CommunicationProtocolConstructionError;
import pala.apps.arlith.backend.common.protocol.types.CommunicationProtocolType;
import pala.apps.arlith.backend.common.protocol.types.TextValue;
import pala.apps.arlith.backend.connections.networking.Connection;
import pala.apps.arlith.backend.connections.scp.CommunicationConnection;
import pala.libs.generic.json.JSONObject;
import pala.libs.generic.json.JSONValue;

/**
 * <h1>{@link CommunicationProtocolRequest}</h1>
 * <p>
 * Represents a Communication Protocol request (which are communicated primarily
 * using JSON). Communication Protocol requests have a name, some valid
 * parameterization, a return type, and a set of valid
 * {@link CommunicationProtocolError}s that can occur during processing of the
 * request (similar to methods/functions in Java, although more lax with the
 * parameter list). Each request is sent (primarily) over JSON, but some
 * requests may have additional parts that are not sent over JSON.
 * </p>
 * <h2>Structure</h2>
 * <p>
 * Every {@link CommunicationProtocolRequest} first sends a "JSON package" to
 * the server. This package generally contains all the information needed to
 * call the request on the server (the name and arguments for the request) that
 * <i>naturally fits in the JSON format</i>. Such typically ends up being data
 * like names, numbers, and simple lists/maps.
 * </p>
 * <p>
 * {@link CommunicationProtocolRequest}s may then, <i>optionally</i>, send
 * additional data, (referred to as <i>auxiliary data</i>), to the server
 * through {@link #sendAuxiliaryData(CommunicationConnection)}. For requests that
 * need this, this is most often images, videos, audio data, or other forms of
 * bulk or arbitrary data.
 * </p>
 * <p>
 * Thereby, not all {@link CommunicationProtocolRequest}s can be represented
 * entirely as JSON (some may include data packages that get sent over the
 * connection, like {@link CreateCommunityRequest}s), but all of them
 * <i>begin</i> by sending a JSON message to the server, (generated by
 * {@link #json()}), that includes the name of the request and any parameters
 * that can be transferred via JSON. <b>This class adds the request name to the
 * JSON package</b> and so such does not need to be done by subclasses in
 * {@link #build(JSONObject)}.
 * </p>
 * <p>
 * For every request, the server parses the JSON payload that was sent at the
 * beginning of the request then parses the name contained therein, (represented
 * in this class by {@link #requestName}), to determine what type of request was
 * sent. The server then invokes the constructor of that request class (the
 * request class should have a constructor that calls
 * {@link #CommunicationProtocolRequest(String, JSONObject)}), providing the
 * {@link JSONObject} payload that was parsed by the server to that constructor.
 * For requests that contain auxiliary data, there should be an appropriate
 * constructor that accepts the {@link Connection} from which the auxiliary data
 * can be read. <b>If the request has sent auxiliary data, the constructor
 * should receive the {@link Connection} that the JSON package was read from and
 * the constructor should read the auxiliary data from the network.</b>
 * </p>
 * <h2>Implementing</h2>
 * <p>
 * Subclasses need to define the following, not necessarily in order:
 * </p>
 * <ol>
 * <li><b>At least one constructor that lets clients generate a new request.</b>
 * <i>See {@link #CommunicationProtocolRequest(String)}</i> - Historically,
 * classes would have constructors that would populate the request to a valid
 * state. (So a {@link ChangeEmailRequest} would have a constructor that takes
 * an email.) Some classes would have multiple constructors, for convenience, or
 * if they could be parameterized in multiple ways.
 * <ul>
 * <li>The constructor(s) would (each) call either
 * {@link #CommunicationProtocolRequest(TextValue)} or
 * {@link #CommunicationProtocolRequest(String)}, and would pass in the
 * <b>formal name of the request</b> (such as <code>change-email</code> to the
 * {@link CommunicationProtocolRequest} constructor. (This is done so that the
 * {@link CommunicationProtocolRequest} class can add the class name to the JSON
 * package automatically when the request is being sent.)</li>
 * </ul>
 * </li>
 * <li><b>A set of <code>set</code>ters</b> allowing client code to change the
 * arguments to the request (modifying the state of this <code>Request</code>
 * object). These setters typically (1) throw an exception if the provided
 * arguments are invalid (e.g. if an attempt is being made to set a non-nullable
 * request argument to <code>null</code>) and (2) return this request object,
 * for chaining convenience.</li>
 * <li><b>A {@link #build(JSONObject)} override</b> that adds all of the
 * JSON-able arguments of the request to the JSON package.</li>
 * <li><b>Possibly, a {@link #sendAuxiliaryData(CommunicationConnection)} override
 * that sends additional data over the network.</b></li>
 * <li><b>A {@link #parseReturnValue(JSONValue, CommunicationConnection)}
 * override</b> that receives the JSON response package and the connection from
 * which the response is being received and parses the <code>R</code> response
 * value from the server. That method <i>should not modify the state of this
 * object</i> and can only return a {@link CommunicationProtocolType}, so typically it either
 * looks like a call <code>new R(json)</code> if no auxiliary data is being
 * received in the server's response or <code>new R(json, connection)</code> if
 * auxiliary data is needed to build the response {@link CommunicationProtocolType}, where
 * <code>json</code> is the received JSON response package and
 * <code>connection</code> is the connection over which the request is being
 * received.</li>
 * <li><b>An override of {@link #receiveResponse(CommunicationConnection)}</b> that
 * <code>throws</code> the types of {@link CommunicationProtocolError}s that the
 * server is allowed to respond with, as well {@link IllegalCommunicationProtocolException}. The
 * method's behavior should be changed to simply <code>try</code> a call to the
 * super method,
 * {@link CommunicationProtocolRequest#receiveResponse(CommunicationConnection)},
 * and then <code>catch</code> the types of {@link CommunicationProtocolError}s
 * the server is allowed to respond with and explicitly rethrow them. The
 * <code>try</code> block should then <code>catch</code> all other
 * {@link CommunicationProtocolError}s and throw an {@link IllegalCommunicationProtocolException}
 * wrapping them. For example, for a request that can throw
 * {@link SyntaxError}s, {@link ServerError}s, {@link RateLimitError}s, and
 * {@link ObjectNotFoundError}s, the method would look like this:
 * 
 * <pre>
 * <code>public R receiveResponse({@link CommunicationConnection} client) throws {@link SyntaxError}, {@link ServerError},
 * 		{@link RateLimitError}, {@link ObjectNotFoundError}, {@link IllegalCommunicationProtocolException} {
 * 	try {
 * 		return super.receiveResponse(client);
 * 	} catch ({@link SyntaxError} | {@link ServerError} | {@link RateLimitError} | {@link ObjectNotFoundError} e) {
 * 		throw e;
 * 	} catch ({@link CommunicationProtocolError} e) {
 * 		throw new {@link IllegalCommunicationProtocolException}(e);
 * 	}
 * }</code>
 * </pre>
 * 
 * <li><b>A constructor that calls
 * {@link #CommunicationProtocolRequest(String, JSONObject)}</b> which exists to
 * allow the server to reconstruct a request from the JSON package (and
 * auxiliary request data) it receives from a client. That constructor usually
 * takes either just the {@link JSONObject} package as a parameter, or the
 * {@link JSONObject} package and the {@link Connection} over which the server
 * has received auxiliary data (and rarely, may also take additional
 * "restriction" arguments, such as for media requests). Such a constructor
 * calls {@link #CommunicationProtocolRequest(String, JSONObject)} providing the
 * formal request name as the first argument to this super constructor. (This
 * super constructor uses the formal request name to verify that the
 * {@link JSONObject} request package actually represents this type of
 * request.)</li>
 * <li>Finally, <b>a set of <code>get</code>ters</b> which allow the server to
 * retrieve the values of the request arguments that were reconstructed after
 * the server received the request.</li>
 * </ol>
 * <h2>General</h2>
 * <p>
 * This class offers facilities for {@link Inquiry Inquiries} that make at most
 * <b>one <i>round</i></b> of communication with the server; subclasses can
 * implement behavior where the client may send any amount of data over the
 * network, and then the server may send any amount of information back, but the
 * client is restricted from <i>then responding</i> to the server.
 * </p>
 * <p>
 * From a high level perspective, subclasses define behavior for:
 * </p>
 * <ul>
 * <li>The client <i>sending</i> the request <i>to the server</i>.
 * <li>The client <i>receiving</i> the response <i>from the server</i>.
 * <li>The server <i>receiving</i> the request <i>from the client</i>.
 * </ul>
 * 
 * @author Palanath
 *
 * @param <R> The return type of the request; what value the client expects to
 *            receive for successful completion of the request.
 */
public abstract class CommunicationProtocolRequest<R extends CommunicationProtocolType> implements Inquiry<R> {

	protected static final String REQUEST_TYPE_KEY = "request";
	protected final TextValue requestName;

	/**
	 * Intended to be called by subclasses through their {@link JSONObject}
	 * constructor. This constructor is used to reconstruct this
	 * {@link CommunicationProtocolRequest} object after its JSON package has been
	 * read from the network connection.
	 * 
	 * @param requiredName The name of this request. This parameter is stored in
	 *                     this object, (in case the request needs to be sent by the
	 *                     caller as a valid {@link #requestName} is needed for
	 *                     such), but it is otherwise used to <i>verify the name</i>
	 *                     of the provided {@link JSONObject} to make sure that that
	 *                     {@link JSONObject} does indeed represent the right type
	 *                     of request. For example, a
	 *                     <code>get-list-of-cool-people</code> request read over
	 *                     the network should contain the JSON object data:
	 * 
	 *                     <pre>
	 * <code>"request" : "get-list-of-cool-people"</code>
	 *                     </pre>
	 * 
	 *                     identifying that JSON package as that type of request. A
	 *                     subclass of this class called
	 *                     <code>GetListOfCoolPeopleRequest</code> would supply
	 *                     <code>"get-list-of-cool-people"</code> as this argument,
	 *                     and this constructor would throw a
	 *                     {@link CommunicationProtocolConstructionError} if the
	 *                     JSON package did not have that name in it.
	 * @param properties   The JSON package of this request. This parameter is used
	 *                     by this constructor to verify that the contained name is
	 *                     equal to what is provided in the previous argument.
	 * 
	 *                     In the future, if generic
	 *                     {@link CommunicationProtocolRequest}s contain additional
	 *                     information, this may be checked or otherwise read from
	 *                     by this class.
	 * @throws CommunicationProtocolConstructionError If the JSON package is not
	 *                                                valid, particularly if the
	 *                                                request type in the package
	 *                                                does not match that specified,
	 *                                                or if none is declared, etc.
	 */
	protected CommunicationProtocolRequest(String requiredName, JSONObject properties)
			throws CommunicationProtocolConstructionError {
		requestName = new TextValue(properties.get(REQUEST_TYPE_KEY));
		if (!requiredName.equals(requestName.getValue()))
			throw new CommunicationProtocolConstructionError("JSON Object does not represent a " + requiredName
					+ " request. Its stored request name: " + requestName.getValue() + '.', properties);
	}

	/**
	 * Convenience constructor that boxes the provided {@link String} in a
	 * {@link TextValue} and calls {@link #CommunicationProtocolRequest(TextValue)}.
	 * 
	 * @param requestName The name/type of the request as a raw string. This is used
	 *                    when building the request. Specifically, this value is put
	 *                    inside the request so that the recipient can identify it.
	 */
	protected CommunicationProtocolRequest(String requestName) {
		this(new TextValue(requestName));
	}

	/**
	 * <p>
	 * Creates a new {@link CommunicationProtocolRequest} with the specified formal
	 * name/type. The name/type is put inside the request so that the recipient can
	 * identify it.
	 * </p>
	 * <p>
	 * Conventionally, the name/type is all-lowercase and is delimited by hyphens
	 * (<code>-</code>) instead of spaces (<code> </code>).
	 * 
	 * @param requestName The name/type of the request.
	 */
	protected CommunicationProtocolRequest(TextValue requestName) {
		this.requestName = requestName;
	}

	/**
	 * <p>
	 * Returns the JSON package of this request. This package is built off of the
	 * current state of this object. The package might not <i>entirely</i> represent
	 * the state of this object nor might it contain <i>all</i> the information in
	 * the request this object represents (see {@link CommunicationProtocolRequest}
	 * documentation for details). This method builds the JSON package by adding the
	 * {@link #requestName request name}, itself, to the object and then by invoking
	 * {@link #build(JSONObject)} on the object.
	 * </p>
	 * <p>
	 * This JSON package is created and sent <i>first</i> when
	 * {@link #sendRequest(CommunicationConnection)} is called. This method can be
	 * called multiple times freely, and should not modify the state of this object.
	 * </p>
	 * 
	 * @return A new {@link JSONObject} that represents the JSON package to be sent
	 *         along with this request.
	 */
	public final JSONObject json() {
		JSONObject object = new JSONObject();
		object.put(REQUEST_TYPE_KEY, requestName.json());
		build(object);
		return object;
	}

	/**
	 * <p>
	 * Adds all the applicable properties that this
	 * {@link CommunicationProtocolRequest} stores to this
	 * {@link CommunicationProtocolRequest}.
	 * </p>
	 * <p>
	 * Properties declared and defined in the {@link CommunicationProtocolRequest}
	 * class need not be added, as they are added by that class in its
	 * {@link #json()} method. That method also calls this method for subclasses to
	 * be able to modify the returned {@link JSONObject}.
	 * </p>
	 * 
	 * @param object The {@link JSONObject} to add the properties to. See
	 *               {@link CommunicationProtocolRequest} for more details on what
	 *               data should be added.
	 * @author Palanath
	 */
	protected abstract void build(JSONObject object);

	/**
	 * Sends this {@link CommunicationProtocolRequest} over the connection to the
	 * server. This method sends the {@link CommunicationProtocolRequest}'s JSON
	 * data package and then calls {@link #sendAuxiliaryData(CommunicationConnection)}
	 * to send any auxiliary data that the request may need to forward to the
	 * server.
	 */
	@Override
	public final void sendRequest(CommunicationConnection client) {
		client.sendJSON(json());
		sendAuxiliaryData(client);
	}

	/**
	 * <p>
	 * Sends any auxiliary data along with this request to the server. Some
	 * requests, such as those that upload media, need to send auxiliary data to the
	 * server after the JSON package representing (most of) the request is sent.
	 * </p>
	 * <p>
	 * By default, this method does nothing.
	 * </p>
	 * 
	 * @param connection The connection over which to send the data. Read methods on
	 *                   this object should not be called as per the specification
	 *                   of this class.
	 */
	protected void sendAuxiliaryData(CommunicationConnection connection) {

	}

	/**
	 * <p>
	 * Parses the value the server returned in response to this request from the
	 * {@link JSONValue} provided. The {@link JSONValue} does not represent a
	 * natural communication protocol error response (such a case should be handled
	 * by the calling method). The connection itself is provided so that arbitrary
	 * auxiliary data may be read from the network stream, if any exists.
	 * </p>
	 * <p>
	 * This method should <b>not</b> modify this object; this method simply reads
	 * the result that the <i>server</i> sends back to the <i>client</i>. This
	 * method is not for reconstructing this object.
	 * </p>
	 * 
	 * @param json       The {@link JSONValue} representing the server's response
	 *                   value for this request.
	 * @param connection The {@link CommunicationConnection} for reading any auxiliary
	 *                   data.
	 * @return The parsed response from the server.
	 */
	protected abstract R parseReturnValue(JSONValue json, CommunicationConnection connection);

	private R parseResult(JSONValue value, CommunicationConnection connection)
			throws CommunicationProtocolError, CommunicationProtocolConstructionError {
		CommunicationProtocolErrorDiscerner.checkErrors(value);
		return parseReturnValue(value, connection);
	}

	/**
	 * <p>
	 * {@inheritDoc}
	 * </p>
	 * <p>
	 * This method reads the JSON response sent back by the server and throws an
	 * {@link CommunicationProtocolError} if it represents one. If it does not
	 * represent an error (if the server did not send back an error), then this
	 * method provides the read {@link JSONValue} to
	 * {@link #parseReturnValue(JSONValue, CommunicationConnection)}, along with the
	 * connection itself in case
	 * {@link #parseReturnValue(JSONValue, CommunicationConnection)} needs to read any
	 * auxiliary data from the connection. The result of
	 * {@link #parseReturnValue(JSONValue, CommunicationConnection)} is returned.
	 * </p>
	 * <p>
	 * This method should be overridden only so that final children can reify the
	 * exception types of the method's <code>throws</code> clause. Such overrides
	 * should
	 * 
	 * <pre>
	 * <code>try {
	 * 	super.receiveResponse(client)
	 * } catch (More | Specific | Exceptions e) {
	 * 	throw e;
	 * } catch ({@link CommunicationProtocolError} e) {
	 * 	throw new {@link IllegalCommunicationProtocolException}(e);
	 * }</code>
	 * </pre>
	 * 
	 * and throw more specific exceptions directly, but wrap exceptions that should
	 * not have been returned in an {@link IllegalCommunicationProtocolException}.
	 * </p>
	 */
	@Override
	public R receiveResponse(CommunicationConnection client) throws CommunicationProtocolError {
		return parseResult(CommunicationProtocolErrorDiscerner.checkErrors(client.readJSON()), client);
	}

}